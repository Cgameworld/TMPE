diff --git a/TLM/TLM/ExampleScript.cs b/TLM/TLM/ExampleScript.cs
deleted file mode 100644
index 1693709..0000000
--- a/TLM/TLM/ExampleScript.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-//You can copy this script's file and use it for your own scripts
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Reflection;
-using System.IO;
-using System.Linq;
-using ColossalFramework.UI;
-using UnityEngine;
-
-namespace ModTools.Scripting
-{
-    class ExampleScript : IModEntryPoint
-    {
-        public void OnModLoaded()
-        {
-            throw new Exception("Hello World!"); //replace this line with your script
-        }
-        public void OnModUnloaded()
-        {
-            throw new Exception("Goodbye Cruel World!"); //replace this line with your clean up script
-        }
-    }
-}
\ No newline at end of file
diff --git a/TLM/TLM/Manager/Impl/ExtNodeManager.cs b/TLM/TLM/Manager/Impl/ExtNodeManager.cs
index 4e92c7d..7fd274e 100644
--- a/TLM/TLM/Manager/Impl/ExtNodeManager.cs
+++ b/TLM/TLM/Manager/Impl/ExtNodeManager.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.Manager.Impl {
+﻿namespace TrafficManager.Manager.Impl {
     using API.Geometry;
     using API.Manager;
     using API.Traffic.Data;
@@ -29,32 +29,6 @@ namespace TrafficManager.Manager.Impl {
             }
         }
 
-        /// <summary>
-        /// assuming highway rules are on, does the junction follow highway rules?
-        /// </summary>
-        /// <param name=""></param>
-        /// <returns></returns>
-        public static bool JunctionHasHighwayRules(ushort nodeId) {
-            return IsHighwayJunction(nodeId) && !LaneConnectionManager.Instance.HasNodeConnections(nodeId);
-        }
-
-        /// <summary>
-        /// Are all segments at nodeId highways?
-        /// </summary>
-        /// <param name="nodeId"></param>
-        /// <returns></returns>
-        public static bool IsHighwayJunction(ushort nodeId) {
-            IExtSegmentManager segMan = Constants.ManagerFactory.ExtSegmentManager;
-            bool ret = true;
-            Constants.ServiceFactory.NetService.IterateNodeSegments(
-                nodeId,
-                (ushort segmentId, ref NetSegment segment) => {
-                    ret &= segMan.CalculateIsHighway(segmentId);
-                    return ret;
-                });
-            return ret;
-        }
-
         public bool IsValid(ushort nodeId) {
             return Services.NetService.IsNodeValid(nodeId);
         }
diff --git a/TLM/TLM/Manager/Impl/ExtSegmentEndManager.cs b/TLM/TLM/Manager/Impl/ExtSegmentEndManager.cs
index 95f9a5d..107be02 100644
--- a/TLM/TLM/Manager/Impl/ExtSegmentEndManager.cs
+++ b/TLM/TLM/Manager/Impl/ExtSegmentEndManager.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.Manager.Impl {
+﻿namespace TrafficManager.Manager.Impl {
     using System;
     using API.Manager;
     using API.Traffic.Data;
@@ -176,20 +176,6 @@ namespace TrafficManager.Manager.Impl {
             return CalculateArrowDirection(sourceDir, targetDir);
         }
 
-        public ArrowDirection GetDirection(ushort segmentId0, ushort segmentId1, ushort nodeId = 0) {
-            if (nodeId == 0) {
-                ref NetSegment seg = ref Singleton<NetManager>.instance.m_segments.m_buffer[0];
-                nodeId = seg.GetSharedNode(segmentId1);
-                if(nodeId == 0) {
-                    return ArrowDirection.None;
-                }
-            }
-            GenericGameBridge.Service.INetService netService = Constants.ServiceFactory.NetService;
-            ref ExtSegmentEnd segmenEnd0 = ref ExtSegmentEnds[GetIndex(segmentId0, nodeId)];
-            ArrowDirection dir = GetDirection(ref segmenEnd0, segmentId1);
-            return dir;
-        }
-
         private ArrowDirection CalculateArrowDirection(Vector3 sourceDir, Vector3 targetDir) {
             sourceDir.y = 0;
             sourceDir.Normalize();
diff --git a/TLM/TLM/Manager/Impl/ExtSegmentManager.cs b/TLM/TLM/Manager/Impl/ExtSegmentManager.cs
index ef30d88..4660516 100644
--- a/TLM/TLM/Manager/Impl/ExtSegmentManager.cs
+++ b/TLM/TLM/Manager/Impl/ExtSegmentManager.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.Manager.Impl {
+﻿namespace TrafficManager.Manager.Impl {
     using API.Manager;
     using API.Traffic.Data;
     using ColossalFramework;
diff --git a/TLM/TLM/Manager/Impl/LaneArrowManager.cs b/TLM/TLM/Manager/Impl/LaneArrowManager.cs
index b94cc75..75fdff6 100644
--- a/TLM/TLM/Manager/Impl/LaneArrowManager.cs
+++ b/TLM/TLM/Manager/Impl/LaneArrowManager.cs
@@ -10,7 +10,6 @@ namespace TrafficManager.Manager.Impl {
     using GenericGameBridge.Service;
     using State;
     using UnityEngine;
-    using TrafficManager.Util;
 
     public class LaneArrowManager
         : AbstractGeometryObservingManager,
@@ -46,21 +45,6 @@ namespace TrafficManager.Manager.Impl {
 
             return false;
         }
-        public bool AddLaneArrows(uint laneId,
-                                  LaneArrows flags,
-                                  bool overrideHighwayArrows = false) {
-
-            LaneArrows flags2 = GetFinalLaneArrows(laneId);
-            return SetLaneArrows(laneId, flags | flags2, overrideHighwayArrows);
-        }
-
-        public bool RemoveLaneArrows(uint laneId,
-                          LaneArrows flags,
-                          bool overrideHighwayArrows = false) {
-
-            LaneArrows flags2 = GetFinalLaneArrows(laneId);
-            return SetLaneArrows(laneId, ~flags & flags2, overrideHighwayArrows);
-        }
 
         public bool ToggleLaneArrows(uint laneId,
                                      bool startNode,
@@ -237,44 +221,6 @@ namespace TrafficManager.Manager.Impl {
             return Instance;
         }
 
-        /// <summary>
-        /// returns the number of all target lanes from input segment toward the secified direction.
-        /// </summary>
-        private static int CountTargetLanesTowardDirection(ushort segmentId, ushort nodeId, ArrowDirection dir) {
-            int count = 0;
-            ref NetSegment seg = ref Singleton<NetManager>.instance.m_segments.m_buffer[segmentId];
-            bool startNode = seg.m_startNode == nodeId;
-            IExtSegmentEndManager segEndMan = Constants.ManagerFactory.ExtSegmentEndManager;
-            ExtSegmentEnd segEnd = segEndMan.ExtSegmentEnds[segEndMan.GetIndex(segmentId, startNode)];
-
-            LaneArrowManager.Instance.Services.NetService.IterateNodeSegments(
-                nodeId,
-                (ushort otherSegmentId, ref NetSegment otherSeg) => {
-                    ArrowDirection dir2 = segEndMan.GetDirection(ref segEnd, otherSegmentId);
-                    if (dir == dir2) {
-                        int forward = 0, backward = 0;
-                        otherSeg.CountLanes(
-                            otherSegmentId,
-                            NetInfo.LaneType.Vehicle | NetInfo.LaneType.TransportVehicle,
-                            VehicleInfo.VehicleType.Car,
-                            ref forward,
-                            ref backward);
-                        bool startNode2 = otherSeg.m_startNode == nodeId;
-                            //xor because inverting 2 times is redundant.
-                            if (startNode2) {
-                            count += forward;
-                        } else {
-                            count += backward;
-                        }
-                        Log._Debug(
-                            $"dir={dir} startNode={startNode} segmentId={segmentId}\n" +
-                            $"startNode2={startNode2} forward={forward} backward={backward} count={count}");
-                    }
-                    return true;
-                });
-            return count;
-        }
-
         public static class SeparateTurningLanes{
             /// <summary>
             /// separates turning lanes for all segments attached to nodeId
@@ -293,7 +239,7 @@ namespace TrafficManager.Manager.Impl {
                     res = SetLaneArrowError.LaneConnection;
                     return;
                 }
-                if (Options.highwayRules && ExtNodeManager.JunctionHasHighwayRules(nodeId)) {
+                if (Options.highwayRules && IsHighwayJunction(nodeId)) {
                     res = SetLaneArrowError.HighwayArrows;
                     return;
                 }
@@ -310,42 +256,29 @@ namespace TrafficManager.Manager.Impl {
                 Debug.Assert(res == SetLaneArrowError.Success);
             }
 
-            public static SetLaneArrowError CanChangeLanes(ushort segmentId, ushort nodeId) {
-                if (segmentId == 0 || nodeId == 0) {
-                    return SetLaneArrowError.Invalid;
-                }
-                if (Options.highwayRules && ExtNodeManager.JunctionHasHighwayRules(nodeId)) {
-                    return SetLaneArrowError.HighwayArrows;
-                }
-
-                ref NetSegment seg = ref Singleton<NetManager>.instance.m_segments.m_buffer[segmentId];
-                bool startNode = seg.m_startNode == nodeId;
-                //list of outgoing lanes from current segment to current node.
-                IList<LanePos> laneList =
-                    Constants.ServiceFactory.NetService.GetSortedLanes(
-                        segmentId,
-                        ref seg,
-                        startNode,
-                        LaneArrowManager.LANE_TYPES,
-                        LaneArrowManager.VEHICLE_TYPES,
-                        true
-                        );
-                int srcLaneCount = laneList.Count();
-                for (int i = 0; i < srcLaneCount; ++i) {
-                    if (LaneConnectionManager.Instance.HasConnections(laneList[i].laneId, startNode)) {
-                        return SetLaneArrowError.LaneConnection; ;
+            private static bool IsHighwayJunction(ushort nodeId) {
+                ref NetNode node = ref Singleton<NetManager>.instance.m_nodes.m_buffer[nodeId];
+                IExtSegmentManager segMan = Constants.ManagerFactory.ExtSegmentManager;
+                bool ret = true;
+                for (int i = 0; i < 8; ++i) {
+                    ushort segmentId = node.GetSegment(i);
+                    if (segmentId != 0) {
+                        ret &= segMan.CalculateIsHighway(segmentId);
                     }
                 }
-
-                return SetLaneArrowError.Success;
+                return ret;
             }
 
             /// <summary>
             /// separates turning lanes for the input segment on the input node.
             /// </summary>
             public static void SeparateSegmentLanes(ushort segmentId, ushort nodeId, out SetLaneArrowError res) {
-                res = CanChangeLanes(segmentId,nodeId);
-                if(res != SetLaneArrowError.Success) {
+                if(segmentId == 0 || nodeId == 0) {
+                    res = SetLaneArrowError.Invalid;
+                    return;
+                }
+                if (Options.highwayRules && IsHighwayJunction(nodeId)) {
+                    res = SetLaneArrowError.HighwayArrows;
                     return;
                 }
                 res = SetLaneArrowError.Success;
@@ -364,13 +297,20 @@ namespace TrafficManager.Manager.Impl {
                         true
                         );
                 int srcLaneCount = laneList.Count();
+                for(int i = 0; i < srcLaneCount; ++i) {
+                    if(LaneConnectionManager.Instance.HasConnections(laneList[i].laneId, startNode)) {
+                        res = SetLaneArrowError.LaneConnection;
+                        return;
+                    }
+                }
+
                 if (srcLaneCount <= 1) {
                     return;
                 }
 
-                int leftLanesCount = LaneArrowManager.CountTargetLanesTowardDirection(segmentId, nodeId, ArrowDirection.Left);
-                int rightLanesCount = LaneArrowManager.CountTargetLanesTowardDirection(segmentId, nodeId, ArrowDirection.Right);
-                int forwardLanesCount = LaneArrowManager.CountTargetLanesTowardDirection(segmentId, nodeId, ArrowDirection.Forward);
+                int leftLanesCount = CountTargetLanesTowardDirection(segmentId, nodeId, ArrowDirection.Left);
+                int rightLanesCount = CountTargetLanesTowardDirection(segmentId, nodeId, ArrowDirection.Right);
+                int forwardLanesCount = CountTargetLanesTowardDirection(segmentId, nodeId, ArrowDirection.Forward);
                 int totalLaneCount = leftLanesCount + forwardLanesCount + rightLanesCount;
                 int numdirs = Convert.ToInt32(leftLanesCount > 0) + Convert.ToInt32(rightLanesCount > 0) + Convert.ToInt32(forwardLanesCount > 0);
 
@@ -438,6 +378,45 @@ namespace TrafficManager.Manager.Impl {
                 }
             }
 
+            /// <summary>
+            /// returns the number of all target lanes from input segment toward the secified direction.
+            /// </summary>
+            private static int CountTargetLanesTowardDirection(ushort segmentId, ushort nodeId, ArrowDirection dir) {
+                int count = 0;
+                ref NetSegment seg = ref Singleton<NetManager>.instance.m_segments.m_buffer[segmentId];
+                bool startNode = seg.m_startNode == nodeId;
+                IExtSegmentEndManager segEndMan = Constants.ManagerFactory.ExtSegmentEndManager;
+                ExtSegmentEnd segEnd = segEndMan.ExtSegmentEnds[segEndMan.GetIndex(segmentId, startNode)];
+
+                LaneArrowManager.Instance.Services.NetService.IterateNodeSegments(
+                    nodeId,
+                    (ushort otherSegmentId, ref NetSegment otherSeg) => {
+                        ArrowDirection dir2 = segEndMan.GetDirection(ref segEnd, otherSegmentId);
+                        if (dir == dir2) {
+                            int forward = 0, backward = 0;
+                            otherSeg.CountLanes(
+                                otherSegmentId,
+                                NetInfo.LaneType.Vehicle | NetInfo.LaneType.TransportVehicle,
+                                VehicleInfo.VehicleType.Car,
+                                ref forward,
+                                ref backward);
+                            bool startNode2 = otherSeg.m_startNode == nodeId;
+
+                            if (startNode2) {
+                                count += forward;
+                            } else {
+                                count += backward;
+                            }
+                            Log._Debug(
+                                $"dir={dir} startNode={startNode} segmentId={segmentId}\n" +
+                                $"startNode2={startNode2} forward={forward} backward={backward} count={count}");
+                        }
+                        return true;
+                    });
+
+                return count;
+            }
+
             /// <summary>
             /// calculates number of lanes in each direction such that the number of
             /// turning lanes are in porportion to the size of the roads they are turning into
diff --git a/TLM/TLM/Manager/Impl/OptionsManager.cs b/TLM/TLM/Manager/Impl/OptionsManager.cs
index cdc0337..3eb8c04 100644
--- a/TLM/TLM/Manager/Impl/OptionsManager.cs
+++ b/TLM/TLM/Manager/Impl/OptionsManager.cs
@@ -1,10 +1,9 @@
-namespace TrafficManager.Manager.Impl {
+﻿namespace TrafficManager.Manager.Impl {
     using System;
     using API.Manager;
     using API.Traffic.Enums;
     using CSUtil.Commons;
     using State;
-    using UI.Helpers;
 
     public class OptionsManager
         : AbstractCustomManager,
@@ -198,21 +197,6 @@ namespace TrafficManager.Manager.Impl {
                 OptionsVehicleRestrictionsTab.SetAddTrafficLightsIfApplicable(data[41] == 1);
             }
 
-            Func<int, ISerializableOptionBase, int> loadBool = (idx, opt) => {
-                if (data.Length > idx) {
-                    opt.Load(data[idx]);
-                }
-                return idx + 1;
-            };
-
-            int index = 42;
-            index = loadBool(index, OptionsMassEditTab.rabout_StayInLaneMainR);
-            index = loadBool(index, OptionsMassEditTab.rabout_StayInLaneNearRabout);
-            index = loadBool(index, OptionsMassEditTab.rabout_DedicatedExitLanes);
-            index = loadBool(index, OptionsMassEditTab.rabout_NoCrossMainR);
-            index = loadBool(index, OptionsMassEditTab.rabout_NoCrossYeildR);
-            index = loadBool(index, OptionsMassEditTab.rabout_PrioritySigns);
-            index = loadBool(index, OptionsMassEditTab.avn_NoCrossMainR);
             return true;
         }
 
@@ -259,15 +243,7 @@ namespace TrafficManager.Manager.Impl {
                 (byte)(Options.turnOnRedEnabled ? 1 : 0),
                 (byte)(Options.allowNearTurnOnRed ? 1 : 0),
                 (byte)(Options.allowFarTurnOnRed ? 1 : 0),
-                (byte)(Options.automaticallyAddTrafficLightsIfApplicable ? 1 : 0),
-
-                (byte)(OptionsMassEditTab.rabout_StayInLaneMainR.Save()),
-                (byte)(OptionsMassEditTab.rabout_StayInLaneNearRabout.Save()),
-                (byte)(OptionsMassEditTab.rabout_DedicatedExitLanes.Save()),
-                (byte)(OptionsMassEditTab.rabout_NoCrossMainR.Save()),
-                (byte)(OptionsMassEditTab.rabout_NoCrossYeildR.Save()),
-                (byte)(OptionsMassEditTab.rabout_PrioritySigns.Save()),
-                (byte)(OptionsMassEditTab.avn_NoCrossMainR.Save()),
+                (byte)(Options.automaticallyAddTrafficLightsIfApplicable ? 1 : 0)
             };
         }
     }
diff --git a/TLM/TLM/State/OptionsTabs/OptionsMassEditTab.cs b/TLM/TLM/State/OptionsTabs/OptionsMassEditTab.cs
deleted file mode 100644
index d090964..0000000
--- a/TLM/TLM/State/OptionsTabs/OptionsMassEditTab.cs
+++ /dev/null
@@ -1,102 +0,0 @@
-namespace TrafficManager.State {
-    using ICities;
-    using UI;
-    using Manager.Impl;
-    using UI.Helpers;
-
-    public static class OptionsMassEditTab {
-        // TODO: Add options to a list.
-        // * i dont have it
-        // < I do not thing it is necessary
-
-        //rabout_DedicatedExitLanes
-        //rabout_SwitchLanesYeildR*<
-        //rabout_SwitchLanesMainR*<
-        //rabout_StayInLaneMainR
-        //rabout_StayInLaneNearRabout
-        //rabout_NoCrossMainR
-        //rabout_NoCrossYeildR
-        //rabout_PrioritySigns
-
-        //avn_NoCrossMainR
-        //avn_NoCrossYield*<
-        //avn_NoLeftTurns*<
-        //avn_EnterBlockedMain*<
-        //avn_EnterBlockedYeild*
-        //avn_StopEntry*
-        //avn_PrioritySigns*
-        //avn_SwitchLanesMain*<
-        //avn_SwtichLanesYeild*<
-
-        //TODO remove comments after adding translations.
-        public static CheckboxOption rabout_DedicatedExitLanes = new CheckboxOption(
-            key: "rabout_DedicatedExitLanes",
-            default_value: true,
-            group_name: "MassEdit",
-            tooltip: true);
-        // label: dedicated exit lanes.
-        // tooltip: one dedicated lane for each exit, the rest of lanes go forw
-
-        public static CheckboxOption rabout_StayInLaneMainR = new CheckboxOption(
-            key: "rabout_StayInLaneMainR",
-            default_value: true,
-            group_name: "MassEdit",
-            true);
-        // Stay in lane inside the roundabout.
-        // If activated, vehicles will stay in lane inside the roundabout may only switch at exits.
-
-        public static CheckboxOption rabout_StayInLaneNearRabout = new CheckboxOption(
-            key: "rabout_StayInLaneNearRabout",
-            default_value: true,
-            group_name: "MassEdit",
-            true);
-        // Stay in lane near the roundabout.
-        // vehicles shall not jam triffc by lane switching too close to the roundabout.
-
-        public static CheckboxOption rabout_NoCrossMainR = new CheckboxOption(
-            key: "rabout_NoCrossMainR",
-            default_value: true,
-            group_name: "MassEdit");
-        // Pedesterians shall not cross to the center of roundabout.
-
-        public static CheckboxOption rabout_NoCrossYeildR = new CheckboxOption(
-            key: "rabout_NoCrossYeildR",
-            default_value: false,
-            group_name: "MassEdit");
-        // Pedesterians shall not cross the roads around the roundabout.
-
-        public static CheckboxOption rabout_PrioritySigns = new CheckboxOption(
-            key: "rabout_PrioritySigns",
-            default_value: true,
-            group_name: "MassEdit");
-        // Add priority signs.
-
-        public static CheckboxOption avn_NoCrossMainR = new CheckboxOption(
-            key: "avn_NoCrossMainR",
-            default_value: true,
-            group_name: "MassEdit");
-        // Pedesterians shall not cross Main avenue at small junctions.
-
-        internal static void MakeSettings_MasEdit(ExtUITabstrip tabStrip, int tabIndex) {
-            UIHelper panelHelper = tabStrip.AddTabPage(T("Tab:MassEdit"));
-            MakePanel_MasEdit(panelHelper);
-        }
-
-        internal static void MakePanel_MasEdit(UIHelperBase panelHelper) {
-            UIHelperBase raboutGroup = panelHelper.AddGroup(
-                T("MassEdit.Group: Roundabouts"));
-            rabout_NoCrossMainR.AddUI(raboutGroup);
-            rabout_NoCrossYeildR.AddUI(raboutGroup);
-            rabout_StayInLaneMainR.AddUI(raboutGroup);
-            rabout_StayInLaneNearRabout.AddUI(raboutGroup);
-            rabout_DedicatedExitLanes.AddUI(raboutGroup);
-            rabout_PrioritySigns.AddUI(raboutGroup);
-
-            UIHelperBase avnGroup = panelHelper.AddGroup(
-                    T("MassEdit.Group.Priority: Priority roads"));
-            avn_NoCrossMainR.AddUI(avnGroup);
-        }
-
-        private static string T(string key) => Translation.Options.Get(key);
-    } // end class
-}
diff --git a/TLM/TLM/State/OptionsTabs/OptionsVehicleRestrictionsTab.cs b/TLM/TLM/State/OptionsTabs/OptionsVehicleRestrictionsTab.cs
index f16ab6b..4adada1 100644
--- a/TLM/TLM/State/OptionsTabs/OptionsVehicleRestrictionsTab.cs
+++ b/TLM/TLM/State/OptionsTabs/OptionsVehicleRestrictionsTab.cs
@@ -5,7 +5,6 @@ namespace TrafficManager.State {
     using ICities;
     using Manager.Impl;
     using UI;
-    using UnityEngine;
     using UI.Helpers;
 
     public static class OptionsVehicleRestrictionsTab {
@@ -119,8 +118,6 @@ namespace TrafficManager.State {
                           Options.evacBussesMayIgnoreRules,
                           OnEvacBussesMayIgnoreRulesChanged) as UICheckBox;
             }
-
-            OptionsMassEditTab.MakePanel_MasEdit(panelHelper);
         }
 
         private static void OnAllRelaxedChanged(bool newAllRelaxed) {
diff --git a/TLM/TLM/TLM.csproj b/TLM/TLM/TLM.csproj
index c70e7f6..4875151 100644
--- a/TLM/TLM/TLM.csproj
+++ b/TLM/TLM/TLM.csproj
@@ -1,10 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <Import Project="..\packages\Microsoft.CodeAnalysis.FxCopAnalyzers.2.9.7\build\Microsoft.CodeAnalysis.FxCopAnalyzers.props" Condition="Exists('..\packages\Microsoft.CodeAnalysis.FxCopAnalyzers.2.9.7\build\Microsoft.CodeAnalysis.FxCopAnalyzers.props')" />
-  <Import Project="..\packages\Microsoft.NetFramework.Analyzers.2.9.7\build\Microsoft.NetFramework.Analyzers.props" Condition="Exists('..\packages\Microsoft.NetFramework.Analyzers.2.9.7\build\Microsoft.NetFramework.Analyzers.props')" />
-  <Import Project="..\packages\Microsoft.NetCore.Analyzers.2.9.7\build\Microsoft.NetCore.Analyzers.props" Condition="Exists('..\packages\Microsoft.NetCore.Analyzers.2.9.7\build\Microsoft.NetCore.Analyzers.props')" />
-  <Import Project="..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\build\Microsoft.CodeQuality.Analyzers.props" Condition="Exists('..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\build\Microsoft.CodeQuality.Analyzers.props')" />
-  <Import Project="..\packages\Microsoft.CodeAnalysis.VersionCheckAnalyzer.2.9.7\build\Microsoft.CodeAnalysis.VersionCheckAnalyzer.props" Condition="Exists('..\packages\Microsoft.CodeAnalysis.VersionCheckAnalyzer.2.9.7\build\Microsoft.CodeAnalysis.VersionCheckAnalyzer.props')" />
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
@@ -18,8 +13,6 @@
     <FileAlignment>512</FileAlignment>
     <TargetFrameworkProfile />
     <LangVersion>latest</LangVersion>
-    <NuGetPackageImportStamp>
-    </NuGetPackageImportStamp>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -210,7 +203,6 @@
     <Compile Include="State\OptionsTabs\OptionsGeneralTab.cs" />
     <Compile Include="State\OptionsTabs\OptionsKeybindsTab.cs" />
     <Compile Include="State\OptionsTabs\OptionsMaintenanceTab.cs" />
-    <Compile Include="State\OptionsTabs\OptionsMassEditTab.cs" />
     <Compile Include="State\OptionsTabs\OptionsOverlaysTab.cs" />
     <Compile Include="State\OptionsTabs\OptionsVehicleRestrictionsTab.cs" />
     <Compile Include="TrafficLight\Impl\CustomSegmentLights.cs" />
@@ -228,10 +220,6 @@
     <Compile Include="Traffic\ExtVehicleType.cs" />
     <Compile Include="Traffic\Impl\SegmentEnd.cs" />
     <Compile Include="UI\CustomKeyHandler.cs" />
-    <Compile Include="UI\Helpers\CheckboxOption.cs" />
-    <Compile Include="UI\Helpers\ISerializableOptionBase.cs" />
-    <Compile Include="UI\Helpers\SerializableOptionBase.cs" />
-    <Compile Include="UI\Helpers\SerializableUIOptionBase.cs" />
     <Compile Include="UI\IncompatibleModsPanel.cs" />
     <Compile Include="UI\RemoveCitizenInstanceButtonExtender.cs" />
     <Compile Include="UI\RemoveVehicleButtonExtender.cs" />
@@ -282,15 +270,12 @@
     <Compile Include="UI\UITransportDemand.cs" />
     <Compile Include="Util\Caching\CameraTransformValue.cs" />
     <Compile Include="Util\Caching\GenericArrayCache.cs" />
-    <Compile Include="Util\Shortcuts.cs" />
     <Compile Include="Util\FloatUtil.cs" />
     <Compile Include="Util\GenericObservable.cs" />
     <Compile Include="Util\GenericUnsubscriber.cs" />
     <Compile Include="Util\MathUtil.cs" />
     <Compile Include="Util\LoopUtil.cs" />
     <Compile Include="Util\ModsCompatibilityChecker.cs" />
-    <Compile Include="Util\PriorityRoad.cs" />
-    <Compile Include="Util\RoundaboutMassEdit.cs" />
     <Compile Include="Util\SegmentLaneTraverser.cs" />
     <Compile Include="Util\TextureUtil.cs" />
     <Compile Include="Util\TinyDictionary.cs" />
@@ -442,15 +427,9 @@
     <EmbeddedResource Include="Resources\right_on_red_forbidden.png" />
   </ItemGroup>
   <ItemGroup>
-    <Analyzer Include="..\packages\Microsoft.CodeAnalysis.VersionCheckAnalyzer.2.9.7\analyzers\dotnet\cs\Microsoft.CodeAnalysis.VersionCheckAnalyzer.resources.dll" />
-    <Analyzer Include="..\packages\Microsoft.CodeAnalysis.VersionCheckAnalyzer.2.9.7\analyzers\dotnet\Microsoft.CodeAnalysis.VersionCheckAnalyzer.dll" />
-    <Analyzer Include="..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\analyzers\dotnet\cs\Humanizer.dll" />
-    <Analyzer Include="..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\analyzers\dotnet\cs\Microsoft.CodeQuality.Analyzers.dll" />
-    <Analyzer Include="..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\analyzers\dotnet\cs\Microsoft.CodeQuality.CSharp.Analyzers.dll" />
-    <Analyzer Include="..\packages\Microsoft.NetCore.Analyzers.2.9.7\analyzers\dotnet\cs\Microsoft.NetCore.Analyzers.dll" />
-    <Analyzer Include="..\packages\Microsoft.NetCore.Analyzers.2.9.7\analyzers\dotnet\cs\Microsoft.NetCore.CSharp.Analyzers.dll" />
-    <Analyzer Include="..\packages\Microsoft.NetFramework.Analyzers.2.9.7\analyzers\dotnet\cs\Microsoft.NetFramework.Analyzers.dll" />
-    <Analyzer Include="..\packages\Microsoft.NetFramework.Analyzers.2.9.7\analyzers\dotnet\cs\Microsoft.NetFramework.CSharp.Analyzers.dll" />
+    <None Include="packages.config" />
+  </ItemGroup>
+  <ItemGroup>
     <Analyzer Include="..\packages\ReflectionIT.Analyzer.Structs.0.1.0\analyzers\dotnet\cs\ReflectionIT.Analyzer.Structs.dll" />
     <Analyzer Include="..\packages\StyleCop.Analyzers.1.0.2\analyzers\dotnet\cs\StyleCop.Analyzers.CodeFixes.dll" />
     <Analyzer Include="..\packages\StyleCop.Analyzers.1.0.2\analyzers\dotnet\cs\StyleCop.Analyzers.dll" />
@@ -569,16 +548,6 @@ set DEPLOYDIR=</PostBuildEvent>
     <PreBuildEvent>
     </PreBuildEvent>
   </PropertyGroup>
-  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
-    <PropertyGroup>
-      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
-    </PropertyGroup>
-    <Error Condition="!Exists('..\packages\Microsoft.CodeAnalysis.VersionCheckAnalyzer.2.9.7\build\Microsoft.CodeAnalysis.VersionCheckAnalyzer.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.CodeAnalysis.VersionCheckAnalyzer.2.9.7\build\Microsoft.CodeAnalysis.VersionCheckAnalyzer.props'))" />
-    <Error Condition="!Exists('..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\build\Microsoft.CodeQuality.Analyzers.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.CodeQuality.Analyzers.2.9.7\build\Microsoft.CodeQuality.Analyzers.props'))" />
-    <Error Condition="!Exists('..\packages\Microsoft.NetCore.Analyzers.2.9.7\build\Microsoft.NetCore.Analyzers.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.NetCore.Analyzers.2.9.7\build\Microsoft.NetCore.Analyzers.props'))" />
-    <Error Condition="!Exists('..\packages\Microsoft.NetFramework.Analyzers.2.9.7\build\Microsoft.NetFramework.Analyzers.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.NetFramework.Analyzers.2.9.7\build\Microsoft.NetFramework.Analyzers.props'))" />
-    <Error Condition="!Exists('..\packages\Microsoft.CodeAnalysis.FxCopAnalyzers.2.9.7\build\Microsoft.CodeAnalysis.FxCopAnalyzers.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.CodeAnalysis.FxCopAnalyzers.2.9.7\build\Microsoft.CodeAnalysis.FxCopAnalyzers.props'))" />
-  </Target>
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
diff --git a/TLM/TLM/UI/Helpers/CheckboxOption.cs b/TLM/TLM/UI/Helpers/CheckboxOption.cs
deleted file mode 100644
index e40f665..0000000
--- a/TLM/TLM/UI/Helpers/CheckboxOption.cs
+++ /dev/null
@@ -1,38 +0,0 @@
-namespace TrafficManager.UI.Helpers {
-    using ICities;
-    using ColossalFramework.UI;
-
-    public sealed class CheckboxOption : SerializableUIOptionBase<bool, UICheckBox> {
-        public event ICities.OnCheckChanged OnValueChanged;
-        public CheckboxOption(
-            string key,
-            bool default_value,
-            string group_name,
-            bool tooltip = false)
-            : base(key, default_value, group_name, tooltip) {
-            OnValueChanged = DefaultOnValueChanged;
-        }
-        public override bool Value {
-            get => base.Value;
-            set {
-                base.Value = value;
-                if (_ui != null) {
-                    _ui.isChecked = value;
-                }
-            }
-        }
-
-        public override void Load(byte data) => Value = (data != 0);
-        public override byte Save() => Value ? (byte)1 : (byte)0;
-
-        public override void AddUI(UIHelperBase container) {
-            _ui = container.AddCheckbox(
-                Translation.Options.Get(Label),
-                DefaultValue,
-                this.OnValueChanged) as UICheckBox;
-            if (_tooltip) {
-                _ui.tooltip = Translation.Options.Get(Tooltip);
-            }
-        }
-    }
-}
diff --git a/TLM/TLM/UI/Helpers/ISerializableOptionBase.cs b/TLM/TLM/UI/Helpers/ISerializableOptionBase.cs
deleted file mode 100644
index 6e1ae7e..0000000
--- a/TLM/TLM/UI/Helpers/ISerializableOptionBase.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-namespace TrafficManager.UI.Helpers {
-    public interface ISerializableOptionBase
-    {
-        public void Load(byte data);
-        public byte Save();
-    }
-}
diff --git a/TLM/TLM/UI/Helpers/SerializableOptionBase.cs b/TLM/TLM/UI/Helpers/SerializableOptionBase.cs
deleted file mode 100644
index 88937d2..0000000
--- a/TLM/TLM/UI/Helpers/SerializableOptionBase.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-//TODO remove file
-namespace TrafficManager.UI.Helpers {
-    using System;
-    using System.Runtime.Serialization;
-
-    //TODO issue #562: Inherit ISerializable Interface or something.
-    //[Serializable()]
-    public abstract class SerializableOptionBase<TVal>: ISerializableOptionBase
-    {
-        public abstract void Load(byte data);
-        public abstract byte Save();
-
-        protected TVal _value;
-        public readonly TVal DefaultValue;
-        public TVal Value {
-            get => _value;
-            set => _value = value;
-        }
-        protected SerializableOptionBase(TVal defaultValue) => _value = DefaultValue = defaultValue;
-    }
-}
diff --git a/TLM/TLM/UI/Helpers/SerializableUIOptionBase.cs b/TLM/TLM/UI/Helpers/SerializableUIOptionBase.cs
deleted file mode 100644
index eb08582..0000000
--- a/TLM/TLM/UI/Helpers/SerializableUIOptionBase.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-namespace TrafficManager.UI.Helpers {
-    using ColossalFramework.UI;
-    using CSUtil.Commons;
-    using ICities;
-    using State;
-
-    //TODO issue #562: implement ISerializable Interface
-    //[Serializable()]
-    public abstract class SerializableUIOptionBase<TVal, TUI> : ISerializableOptionBase
-        where TUI : UIComponent {
-        //Data:
-        protected TVal _value;
-        public readonly TVal DefaultValue;
-        public virtual TVal Value {
-            get => _value;
-            set => _value = value;
-        }
-        public static implicit operator TVal(SerializableUIOptionBase<TVal,TUI> a) => a.Value;
-
-        public abstract void Load(byte data);
-        public abstract byte Save();
-
-        //UI:
-        public abstract void AddUI(UIHelperBase container);
-        protected TUI _ui;
-        protected readonly bool _tooltip;
-        public string Key;
-        public string GroupName;
-        public string Label { get => $"{GroupName}.CheckBox: {Key}"; }
-        public string Tooltip { get => $"{GroupName}.Tooltip: {Key}"; }
-        public void DefaultOnValueChanged(TVal newVal) {
-            Options.IsGameLoaded();
-            Log._Debug($"{GroupName}.{Label} changed to {newVal}");
-            _value = newVal;
-        }
-
-        public SerializableUIOptionBase(
-            string key,
-            TVal default_value,
-            string group_name,
-            bool tooltip = false)
-        {
-            _value = DefaultValue = default_value;
-            Key = key;
-            GroupName = group_name;
-            _tooltip = tooltip;
-        }
-    }
-}
diff --git a/TLM/TLM/UI/SubTools/JunctionRestrictionsTool.cs b/TLM/TLM/UI/SubTools/JunctionRestrictionsTool.cs
index 711a2c1..4efbc3c 100644
--- a/TLM/TLM/UI/SubTools/JunctionRestrictionsTool.cs
+++ b/TLM/TLM/UI/SubTools/JunctionRestrictionsTool.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.UI.SubTools {
+﻿namespace TrafficManager.UI.SubTools {
     using System.Collections.Generic;
     using API.Manager;
     using ColossalFramework;
@@ -43,7 +43,7 @@ namespace TrafficManager.UI.SubTools {
         }
 
         public override void ShowGUIOverlay(ToolMode toolMode, bool viewOnly) {
-            if (viewOnly && !(Options.junctionRestrictionsOverlay || PrioritySignsTool.showMassEditOverlay)) {
+            if (viewOnly && !Options.junctionRestrictionsOverlay) {
                 return;
             }
 
@@ -163,7 +163,7 @@ namespace TrafficManager.UI.SubTools {
         public override void Initialize() {
             base.Initialize();
             Cleanup();
-            if (Options.junctionRestrictionsOverlay || PrioritySignsTool.showMassEditOverlay) {
+            if (Options.junctionRestrictionsOverlay) {
                 RefreshCurrentRestrictedNodeIds();
             } else {
                 currentRestrictedNodeIds.Clear();
@@ -201,7 +201,7 @@ namespace TrafficManager.UI.SubTools {
             bool hovered = false;
             stateUpdated = false;
 
-            if (viewOnly && !(Options.junctionRestrictionsOverlay || PrioritySignsTool.showMassEditOverlay) &&
+            if (viewOnly && !Options.junctionRestrictionsOverlay &&
                 (MainTool.GetToolMode() != ToolMode.JunctionRestrictions)) {
                 return false;
             }
diff --git a/TLM/TLM/UI/SubTools/LaneConnectorTool.cs b/TLM/TLM/UI/SubTools/LaneConnectorTool.cs
index 590a444..6f5b0ed 100644
--- a/TLM/TLM/UI/SubTools/LaneConnectorTool.cs
+++ b/TLM/TLM/UI/SubTools/LaneConnectorTool.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.UI.SubTools {
+﻿namespace TrafficManager.UI.SubTools {
     using System.Collections.Generic;
     using System.Linq;
     using ColossalFramework;
@@ -19,7 +19,7 @@ namespace TrafficManager.UI.SubTools {
             SelectTarget
         }
 
-        public enum StayInLaneMode {
+        private enum StayInLaneMode {
             None,
             Both,
             Forward,
@@ -104,7 +104,7 @@ namespace TrafficManager.UI.SubTools {
         }
 
         private void ShowOverlay(bool viewOnly, RenderManager.CameraInfo cameraInfo) {
-            if (viewOnly && !(Options.connectedLanesOverlay || PrioritySignsTool.showMassEditOverlay)) {
+            if (viewOnly && !Options.connectedLanesOverlay) {
                 return;
             }
 
@@ -355,13 +355,48 @@ namespace TrafficManager.UI.SubTools {
                     }
 
                     if (stayInLaneMode != StayInLaneMode.None) {
-                        selectedMarker = null;
-                        StayInLane(SelectedNodeId, stayInLaneMode);
-                        RefreshCurrentNodeMarkers(SelectedNodeId);
-                    }
+                        List<NodeLaneMarker> nodeMarkers = GetNodeMarkers(
+                            SelectedNodeId,
+                            ref nodesBuffer[SelectedNodeId]);
 
+                        if (nodeMarkers != null) {
+                            selectedMarker = null;
 
+                            foreach (NodeLaneMarker sourceLaneMarker in nodeMarkers) {
+                                if (!sourceLaneMarker.IsSource) {
+                                    continue;
+                                }
+
+                                if ((stayInLaneMode == StayInLaneMode.Forward) ||
+                                    (stayInLaneMode == StayInLaneMode.Backward)) {
+                                    if ((sourceLaneMarker.SegmentIndex == 0)
+                                        ^ (stayInLaneMode == StayInLaneMode.Backward)) {
+                                        continue;
+                                    }
+                                }
+
+                                foreach (NodeLaneMarker targetLaneMarker in nodeMarkers) {
+                                    if (!targetLaneMarker.IsTarget || (targetLaneMarker.SegmentId ==
+                                                                       sourceLaneMarker.SegmentId)) {
+                                        continue;
+                                    }
+
+                                    if (targetLaneMarker.InnerSimilarLaneIndex
+                                        == sourceLaneMarker.InnerSimilarLaneIndex) {
+                                        Log._Debug(
+                                            $"Adding lane connection {sourceLaneMarker.LaneId} -> " +
+                                            $"{targetLaneMarker.LaneId}");
+                                        LaneConnectionManager.Instance.AddLaneConnection(
+                                            sourceLaneMarker.LaneId,
+                                            targetLaneMarker.LaneId,
+                                            sourceLaneMarker.StartNode);
+                                    }
+                                }
+                            }
+                        }
 
+                        RefreshCurrentNodeMarkers(SelectedNodeId);
+                    } // if stay in lane is not None
                 } // if stay in lane
             } // if selected node
 
@@ -371,49 +406,6 @@ namespace TrafficManager.UI.SubTools {
             }
         }
 
-        public static void StayInLane(ushort nodeId, StayInLaneMode stayInLaneMode = StayInLaneMode.Both) {
-            if (stayInLaneMode != StayInLaneMode.None) {
-                NetNode[] nodesBuffer = Singleton<NetManager>.instance.m_nodes.m_buffer;
-                List<NodeLaneMarker> nodeMarkers = GetNodeMarkers(
-                    nodeId,
-                    ref nodesBuffer[nodeId]);
-
-                if (nodeMarkers != null) {
-                    foreach (NodeLaneMarker sourceLaneMarker in nodeMarkers) {
-                        if (!sourceLaneMarker.IsSource) {
-                            continue;
-                        }
-
-                        if ((stayInLaneMode == StayInLaneMode.Forward) ||
-                            (stayInLaneMode == StayInLaneMode.Backward)) {
-                            if ((sourceLaneMarker.SegmentIndex == 0)
-                                ^ (stayInLaneMode == StayInLaneMode.Backward)) {
-                                continue;
-                            }
-                        }
-
-                        foreach (NodeLaneMarker targetLaneMarker in nodeMarkers) {
-                            if (!targetLaneMarker.IsTarget || (targetLaneMarker.SegmentId ==
-                                                               sourceLaneMarker.SegmentId)) {
-                                continue;
-                            }
-
-                            if (targetLaneMarker.InnerSimilarLaneIndex
-                                == sourceLaneMarker.InnerSimilarLaneIndex) {
-                                Log._Debug(
-                                    $"Adding lane connection {sourceLaneMarker.LaneId} -> " +
-                                    $"{targetLaneMarker.LaneId}");
-                                LaneConnectionManager.Instance.AddLaneConnection(
-                                    sourceLaneMarker.LaneId,
-                                    targetLaneMarker.LaneId,
-                                    sourceLaneMarker.StartNode);
-                            } // end if
-                        } // end foreach
-                    } // end foreach
-                } // end if
-            } // end if
-        }
-
         public override void OnPrimaryClickOverlay() {
 #if DEBUG
             bool logLaneConn = DebugSwitch.LaneConnections.Get();
@@ -642,14 +634,14 @@ namespace TrafficManager.UI.SubTools {
         public override void Initialize() {
             base.Initialize();
             Cleanup();
-            if (Options.connectedLanesOverlay || PrioritySignsTool.showMassEditOverlay) {
+            if (Options.connectedLanesOverlay) {
                 RefreshCurrentNodeMarkers();
             } else {
                 currentNodeMarkers.Clear();
             }
         }
 
-        private static List<NodeLaneMarker> GetNodeMarkers(ushort nodeId, ref NetNode node) {
+        private List<NodeLaneMarker> GetNodeMarkers(ushort nodeId, ref NetNode node) {
             if (nodeId == 0) {
                 return null;
             }
diff --git a/TLM/TLM/UI/SubTools/PrioritySignsTool.cs b/TLM/TLM/UI/SubTools/PrioritySignsTool.cs
index 473dc0f..a2d151e 100644
--- a/TLM/TLM/UI/SubTools/PrioritySignsTool.cs
+++ b/TLM/TLM/UI/SubTools/PrioritySignsTool.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.UI.SubTools {
+﻿namespace TrafficManager.UI.SubTools {
     using System;
     using System.Collections.Generic;
     using API.Manager;
@@ -31,55 +31,40 @@ namespace TrafficManager.UI.SubTools {
         }
 
         public override void OnPrimaryClickOverlay() {
-            bool ctrlDown = Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl);
-            bool shiftDown = Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
-            if(ctrlDown || shiftDown) {
+            if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)) {
                 if (HoveredSegmentId == 0) {
                     return;
                 }
+
                 SelectedNodeId = 0;
-            }
 
-            //TODO provide revert/clear mode  issue #568
-            if (ctrlDown && shiftDown) {
-                bool isRAbout = RoundaboutMassEdit.Instance.FixRabout(HoveredSegmentId);
-                if (!isRAbout) {
-                    PriorityRoad.FixRoad(HoveredSegmentId);
-                }
-                RefreshMassEditOverlay();
-                return;
-            } else if (ctrlDown) {
-                PriorityRoad.FixJunction(HoveredNodeId);
-                RefreshMassEditOverlay();
-                return;
-            } else if (shiftDown) {
                 var primaryPrioType = PriorityType.None;
                 var secondaryPrioType = PriorityType.None;
 
                 switch (massEditMode) {
                     case PrioritySignsMassEditMode.MainYield: {
-                            primaryPrioType = PriorityType.Main;
-                            secondaryPrioType = PriorityType.Yield;
-                            break;
-                        }
+                        primaryPrioType = PriorityType.Main;
+                        secondaryPrioType = PriorityType.Yield;
+                        break;
+                    }
 
                     case PrioritySignsMassEditMode.MainStop: {
-                            primaryPrioType = PriorityType.Main;
-                            secondaryPrioType = PriorityType.Stop;
-                            break;
-                        }
+                        primaryPrioType = PriorityType.Main;
+                        secondaryPrioType = PriorityType.Stop;
+                        break;
+                    }
 
                     case PrioritySignsMassEditMode.YieldMain: {
-                            primaryPrioType = PriorityType.Yield;
-                            secondaryPrioType = PriorityType.Main;
-                            break;
-                        }
+                        primaryPrioType = PriorityType.Yield;
+                        secondaryPrioType = PriorityType.Main;
+                        break;
+                    }
 
                     case PrioritySignsMassEditMode.StopMain: {
-                            primaryPrioType = PriorityType.Stop;
-                            secondaryPrioType = PriorityType.Main;
-                            break;
-                        }
+                        primaryPrioType = PriorityType.Stop;
+                        secondaryPrioType = PriorityType.Main;
+                        break;
+                    }
                 }
 
                 IExtSegmentEndManager segEndMan = Constants.ManagerFactory.ExtSegmentEndManager;
@@ -94,7 +79,7 @@ namespace TrafficManager.UI.SubTools {
                             data.CurSeg.segmentId,
                             startNode);
                         ExtSegmentEnd curEnd = segEndMan.ExtSegmentEnds[
-                            segEndMan.GetIndex(data.CurSeg.segmentId, startNode)];
+                            segEndMan.GetIndex(data.CurSeg.segmentId,startNode)];
 
                         for (int i = 0; i < 8; ++i) {
                             ushort otherSegmentId = Singleton<NetManager>.instance.m_nodes
@@ -122,92 +107,51 @@ namespace TrafficManager.UI.SubTools {
 
                     return true;
                 }
-                bool isRAbout = RoundaboutMassEdit.Instance.TraverseLoop(HoveredSegmentId, out var segmentList);
-                if (isRAbout) {
-                    SegmentTraverser.Traverse(segmentList, VisitorFun);
-                } else {
-                    SegmentTraverser.Traverse(
-                        HoveredSegmentId,
-                        TraverseDirection.AnyDirection,
-                        TraverseSide.Straight,
-                        SegmentStopCriterion.None,
-                        VisitorFun);
-                }
+
+                SegmentTraverser.Traverse(
+                    HoveredSegmentId,
+                    TraverseDirection.AnyDirection,
+                    TraverseSide.Straight,
+                    SegmentStopCriterion.None,
+                    VisitorFun);
 
                 // cycle mass edit mode
                 massEditMode =
                     (PrioritySignsMassEditMode)(((int)massEditMode + 1) %
                                                 Enum.GetValues(typeof(PrioritySignsMassEditMode))
                                                     .GetLength(0));
-            } else {
-                if (TrafficPriorityManager.Instance.HasNodePrioritySign(HoveredNodeId)) {
-                    return;
-                }
 
-                if (!MayNodeHavePrioritySigns(HoveredNodeId)) {
-                    return;
-                }
+                // update priority node cache
+                RefreshCurrentPriorityNodeIds();
+                return;
+            }
 
-                SelectedNodeId = HoveredNodeId;
-                Log._Debug($"PrioritySignsTool.OnPrimaryClickOverlay: SelectedNodeId={SelectedNodeId}");
+            if (TrafficPriorityManager.Instance.HasNodePrioritySign(HoveredNodeId)) {
+                return;
             }
 
+            if (!MayNodeHavePrioritySigns(HoveredNodeId)) {
+                return;
+            }
+
+            SelectedNodeId = HoveredNodeId;
+            Log._Debug($"PrioritySignsTool.OnPrimaryClickOverlay: SelectedNodeId={SelectedNodeId}");
+
             // update priority node cache
             RefreshCurrentPriorityNodeIds();
         }
 
         public override void OnToolGUI(Event e) { }
 
-        /// <summary>
-        /// show overlay for other subtools influced by mass edit.
-        /// </summary>
-        public static bool showMassEditOverlay = false;
-
-        /// <summary>
-        /// refreshes all subtools incflucned by mass edit.
-        /// </summary>
-        private void RefreshMassEditOverlay() {
-            showMassEditOverlay = true;
-            UIBase.GetTrafficManagerTool(false)?.InitializeSubTools();
-            RefreshCurrentPriorityNodeIds();
-            showMassEditOverlay = false;
-        }
-
         public override void RenderOverlay(RenderManager.CameraInfo cameraInfo) {
             if (MainTool.GetToolController().IsInsideUI || !Cursor.visible) {
                 return;
             }
 
-            bool ctrlDown = Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl);
-            bool shiftDown = Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
-
-            if (ctrlDown) {
-                showMassEditOverlay = true;
-                massEditMode = PrioritySignsMassEditMode.MainYield;
-            } else {
-                showMassEditOverlay = false;
-            }
-
-            if (HoveredSegmentId == 0) {
-                if(shiftDown) {
-                    massEditMode = PrioritySignsMassEditMode.MainYield;
-                }
-                return;
-            }
-
-            if (shiftDown) {
-                bool isRAbout = RoundaboutMassEdit.Instance.TraverseLoop(HoveredSegmentId, out var segmentList);
-                Color color = MainTool.GetToolColor(Input.GetMouseButton(0), false);
-                if (isRAbout) {
-                    foreach (uint segmentId in segmentList) {
-                        ref NetSegment seg = ref Singleton<NetManager>.instance.m_segments.m_buffer[segmentId];
-                        NetTool.RenderOverlay(
-                            cameraInfo,
-                            ref seg,
-                            color,
-                            color);
-                    } // end foreach
-                } else {
+            if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)) {
+                // draw hovered segments
+                if (HoveredSegmentId != 0) {
+                    Color color = MainTool.GetToolColor(Input.GetMouseButton(0), false);
                     SegmentTraverser.Traverse(
                         HoveredSegmentId,
                         TraverseDirection.AnyDirection,
@@ -222,10 +166,10 @@ namespace TrafficManager.UI.SubTools {
                                 color);
                             return true;
                         });
+                } else {
+                    massEditMode = PrioritySignsMassEditMode.MainYield;
                 }
-                return;
-            }else if (ctrlDown) {
-                MainTool.DrawNodeCircle(cameraInfo, HoveredNodeId, Input.GetMouseButton(0));
+
                 return;
             }
 
@@ -509,7 +453,7 @@ namespace TrafficManager.UI.SubTools {
             base.Initialize();
             Cleanup();
 
-            if (Options.prioritySignsOverlay ) {
+            if (Options.prioritySignsOverlay) {
                 RefreshCurrentPriorityNodeIds();
             } else {
                 currentPriorityNodeIds.Clear();
diff --git a/TLM/TLM/Util/PriorityRoad.cs b/TLM/TLM/Util/PriorityRoad.cs
deleted file mode 100644
index 2398ad5..0000000
--- a/TLM/TLM/Util/PriorityRoad.cs
+++ /dev/null
@@ -1,434 +0,0 @@
-namespace TrafficManager.Util {
-    using System.Collections.Generic;
-    using ColossalFramework;
-    using API.Manager;
-    using API.Traffic.Data;
-    using TrafficManager.Manager.Impl;
-    using API.Traffic.Enums;
-    using System;
-    using GenericGameBridge.Service;
-    using UnityEngine;
-    using CSUtil.Commons;
-    using static TrafficManager.Util.SegmentTraverser;
-    using State;
-    using System.Linq;
-    using static Util.Shortcuts;
-
-    public static class PriorityRoad {
-
-        private static void Swap(List<ushort> list, int i1, int i2) {
-            ushort temp = list[i1];
-            list[i1] = list[i2];
-            list[i2] = temp;
-        }
-
-        private static LaneArrows ToLaneArrows(ArrowDirection dir) {
-            switch (dir) {
-                case ArrowDirection.Forward:
-                    return LaneArrows.Forward;
-                case ArrowDirection.Left:
-                    return LaneArrows.Left;
-                case ArrowDirection.Right:
-                    return LaneArrows.Right;
-                default:
-                    return LaneArrows.None;
-            }
-        }
-
-        public static void FixRoad(ushort initialSegmentId) {
-            SegmentTraverser.Traverse(
-                initialSegmentId,
-                TraverseDirection.AnyDirection,
-                TraverseSide.Straight,
-                SegmentStopCriterion.None,
-                VisitorFunc);
-        }
-
-        private static bool VisitorFunc(SegmentVisitData data) {
-            ushort segmentId = data.CurSeg.segmentId;
-            foreach (bool startNode in Constants.ALL_BOOL) {
-                ushort nodeId = netService.GetSegmentNodeId(segmentId, startNode);
-                FixJunction(nodeId);
-            }
-            return true;
-        }
-
-        private static bool IsStraighOneWay(ushort segmentId0, ushort segmentId1, ushort nodeId) {
-            ref NetSegment seg0 = ref GetSeg(segmentId0);
-            //ref NetSegment seg1 = ref GetSeg(segmentId1);
-            bool ret = segMan.CalculateIsOneWay(segmentId0) &&
-                       segMan.CalculateIsOneWay(segmentId1);
-            if(!ret) {
-                return false;
-            }
-
-            if (netService.GetHeadNode(segmentId0) == netService.GetTailNode(segmentId1)) {
-                if( GetDirection(segmentId0, segmentId1, nodeId) == ArrowDirection.Forward ) {
-                    return true;
-                }
-            }else if (netService.GetHeadNode(segmentId0) == netService.GetTailNode(segmentId1)) {
-                if (GetDirection(segmentId1, segmentId0, nodeId) == ArrowDirection.Forward) {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        /// <summary>
-        /// If this is the case of a semi roundabout puts the roundabout roads in the
-        /// first two elements of the intput list.
-        /// </summary>
-        /// <param name="segmentList"></param>
-        /// <param name="nodeId"></param>
-        /// <returns>true if it is a semi roundabout</returns>
-        private static bool ArrangeSemiRabout(List<ushort> segmentList, ushort nodeId) {
-            if (segmentList.Count != 3) {
-                return false;
-            } else if (IsStraighOneWay(segmentList[0], segmentList[1], nodeId)) {
-                return true;
-            } else if (IsStraighOneWay(segmentList[1], segmentList[2], nodeId)) {
-                ushort temp = segmentList[0];
-                segmentList[0] = segmentList[1];
-                segmentList[1] = segmentList[2];
-                segmentList[2] = temp;
-                return true;
-            } else if (IsStraighOneWay(segmentList[0], segmentList[2], nodeId)) {
-                ushort temp = segmentList[1];
-                segmentList[1] = segmentList[2];
-                segmentList[2] = temp;
-                return true;
-            }
-            return false;
-        }
-
-        //TODO move to util or extensions
-        public static IList<T> Clone<T>(this IList<T> listToClone) where T : ICloneable {
-            return listToClone.Select(item => (T)item.Clone()).ToList();
-        }
-
-        /// <summary>
-        /// if this is a case of split avenue, arranges the input segment list as follows:
-        /// slot 0: incomming oneway road.
-        /// slot 1: outgoing oneway road.
-        /// slot 2: 2 way raod.
-        /// Note: the arrangement of segmentList might be altered regardless of whether this is
-        /// a case of SplitAvenue.
-        /// </summary>
-        /// <param name="segmentList"></param>
-        /// <param name="nodeId"></param>
-        /// <returns>true if this is a case of split avenue</returns>
-        private static bool ArrangeSplitAvenue(List<ushort> segmentList, ushort nodeId) {
-            if (segmentList.Count != 3) {
-                return false;
-            }
-            bool oneway0 = segMan.CalculateIsOneWay(segmentList[0]);
-            bool oneway1 = segMan.CalculateIsOneWay(segmentList[1]);
-            bool oneway2 = segMan.CalculateIsOneWay(segmentList[1]);
-            int sum = Int(oneway0) + Int(oneway1) + Int(oneway2);
-
-            // put the avenue in slot 2.
-            if (sum != 2) {
-                return false;
-            } else if (!oneway0) {
-                Swap(segmentList, 0, 2);
-            } else if (!oneway1) {
-                Swap(segmentList, 1, 2);
-            }
-
-            // slot 0: incomming road.
-            // slot 1: outgoing road.
-            if (netService.GetHeadNode(segmentList[1]) == netService.GetTailNode(segmentList[0])) {
-                Swap(segmentList, 0, 1);
-            }
-
-            return netService.GetHeadNode(segmentList[0]) == netService.GetTailNode(segmentList[1]);
-        }
-
-        private static void HandleSplitAvenue(List<ushort> segmentList, ushort nodeId) {
-            void SetArrows(ushort segmentIdSrc, ushort segmentIdDst, ushort nodeId) {
-                LaneArrows arrow = ToLaneArrows(GetDirection(segmentIdSrc, segmentIdDst, nodeId));
-                IList<LanePos> lanes = netService.GetSortedLanes(
-                                segmentIdSrc,
-                                ref GetSeg(segmentIdSrc),
-                                netService.IsStartNode(segmentIdSrc, nodeId),
-                                LaneArrowManager.LANE_TYPES,
-                                LaneArrowManager.VEHICLE_TYPES,
-                                true);
-
-                foreach (LanePos lane in lanes) {
-                    LaneArrowManager.Instance.SetLaneArrows(lane.laneId, arrow, true);
-                }
-            }
-
-            SetArrows(segmentList[0], segmentList[2], nodeId);
-            SetArrows(segmentList[2], segmentList[1], nodeId);
-            foreach(ushort segmentId in segmentList) {
-                FixMajorSegmentRules(segmentId, nodeId);
-            }
-        }
-
-        public static void FixJunction(ushort nodeId) {
-            if (nodeId == 0) {
-                return;
-            }
-
-            List<ushort> segmentList = new List<ushort>();
-            for (int i = 0; i < 8; ++i) {
-                ushort segId = GetNode(nodeId).GetSegment(i);
-                if (segId != 0) {
-                    segmentList.Add(segId);
-                }
-            }
-
-            if (segmentList.Count < 3) {
-                // this is not a junctiuon
-                return;
-            }
-
-            if (ArrangeSplitAvenue(segmentList, nodeId)) {
-                HandleSplitAvenue(segmentList, nodeId);
-                return;
-            }
-
-            bool isSemiRabout = ArrangeSemiRabout(segmentList, nodeId);
-
-            if(!isSemiRabout) {
-                segmentList.Sort(CompareSegments);
-                if (CompareSegments(segmentList[1], segmentList[2]) == 0) {
-                    // cannot figure out which road should be treaded as the main road.
-                    return;
-                }
-            }
-
-            // "long turn" is allowed when the main road is oneway.
-            bool ignoreLanes =
-                segMan.CalculateIsOneWay(segmentList[0]) ||
-                segMan.CalculateIsOneWay(segmentList[1]);
-
-            // Turning allowed when the main road is agnled.
-            ArrowDirection dir = GetDirection(segmentList[0], segmentList[1], nodeId);
-            ignoreLanes &= dir != ArrowDirection.Forward;
-
-            //Debug.Log($"ignorelanes={ignoreLanes}");
-
-            for (int i = 0; i < segmentList.Count; ++i) {
-                if (i < 2) {
-                    FixMajorSegmentRules(segmentList[i], nodeId);
-                    if(!ignoreLanes) {
-                        FixMajorSegmentLanes(segmentList[i], nodeId);
-                    }
-                } else {
-                    FixMinorSegmentRules(segmentList, segmentList[i], nodeId);
-                    if (!ignoreLanes) {
-                        FixMinorSegmentLanes(segmentList[i], nodeId, ref segmentList);
-                    }
-                }
-            } //end for
-        } // end method
-
-        private static ArrowDirection GetDirection(ushort segmentId, ushort otherSegmentId, ushort nodeId) {
-            ref ExtSegmentEnd segEnd = ref GetSegEnd(segmentId, nodeId);
-            ArrowDirection dir = segEndMan.GetDirection(ref segEnd, otherSegmentId);
-            return dir;
-        }
-
-        private static void FixMajorSegmentRules(ushort segmentId, ushort nodeId) {
-            bool startNode = (bool)netService.IsStartNode(segmentId, nodeId);
-            JunctionRestrictionsManager.Instance.SetEnteringBlockedJunctionAllowed(segmentId, startNode, true);
-            if(OptionsMassEditTab.avn_NoCrossMainR.Value) {
-                JunctionRestrictionsManager.Instance.SetPedestrianCrossingAllowed(segmentId, startNode, false);
-            }
-            TrafficPriorityManager.Instance.SetPrioritySign(segmentId, startNode, PriorityType.Main);
-        }
-
-
-        private static void FixMinorSegmentRules(List<ushort> segmentList, ushort segmentId, ushort nodeId) {
-            bool startNode = (bool)netService.IsStartNode(segmentId, nodeId);
-            if(HasAccelerationLane( segmentList, segmentId, nodeId)) {
-                JunctionRestrictionsManager.Instance.SetEnteringBlockedJunctionAllowed(segmentId, startNode, true);
-            } else {
-                TrafficPriorityManager.Instance.SetPrioritySign(segmentId, startNode, PriorityType.Yield);
-            }
-        }
-
-        //TODO move to ExtSegmentManager
-        private static int CountLanes(ushort segmentId, ushort nodeId, bool outgoing = true) {
-            return netService.GetSortedLanes(
-                                segmentId,
-                                ref GetSeg(segmentId),
-                                netService.IsStartNode(segmentId, nodeId) ^ (!outgoing),
-                                LaneArrowManager.LANE_TYPES,
-                                LaneArrowManager.VEHICLE_TYPES,
-                                true
-                                ).Count;
-        }
-        private static int CountOutgoingLanes(ushort segmentId, ushort nodeId) => CountLanes(segmentId, nodeId, true);
-        private static int CountIncomingLanes(ushort segmentId, ushort nodeId) => CountLanes(segmentId, nodeId, false);
-
-
-        private static bool HasAccelerationLane(List<ushort> segmentList, ushort segmentId, ushort nodeId) {
-            bool lhd = LaneArrowManager.Instance.Services.SimulationService.LeftHandDrive;
-            if (!segMan.CalculateIsOneWay(segmentId)) {
-                return false;
-            }
-            bool IsMain(ushort segId) {
-                return segId == segmentList[0] || segId == segmentList[1];
-            }
-            ref NetSegment seg = ref GetSeg(segmentId);
-
-            ushort mainIn, mainOut;
-            if (lhd) {
-                mainOut = seg.GetLeftSegment(nodeId);
-                mainIn = seg.GetRightSegment(nodeId);
-            } else {
-                mainOut = seg.GetRightSegment(nodeId);
-                mainIn = seg.GetLeftSegment(nodeId);
-            }
-
-            //Debug.Log($"segmentId:{segmentId} mainOut={mainOut} mainIn={mainIn} ");
-            if (IsMain(mainOut) && IsMain(mainIn) ) {
-                int Oy = CountOutgoingLanes(segmentId, nodeId);
-                int Mo = CountOutgoingLanes(mainOut, nodeId);
-                int Mi = CountIncomingLanes(mainIn, nodeId);
-                bool ret = Oy > 0 && Oy == Mo - Mi;
-                //Debug.Log($"Oy={Oy} Mo={Mo} Mi={Mi} ret={ret} = Oy == Mo - Mi ");
-                return ret;
-            }
-
-            return false;
-        }
-
-        private static void FixMajorSegmentLanes(ushort segmentId, ushort nodeId) {
-            if (LaneArrowManager.SeparateTurningLanes.CanChangeLanes(segmentId, nodeId) != SetLaneArrowError.Success) {
-                Debug.Log("cant change lanes");
-                return;
-            }
-
-            ref NetSegment seg = ref GetSeg(segmentId);
-            ref NetNode node = ref GetNode(nodeId);
-            bool startNode = (bool)netService.IsStartNode(segmentId, nodeId);
-
-            //list of outgoing lanes from current segment to current node.
-            IList<LanePos> laneList =
-                netService.GetSortedLanes(
-                    segmentId,
-                    ref seg,
-                    startNode,
-                    LaneArrowManager.LANE_TYPES,
-                    LaneArrowManager.VEHICLE_TYPES,
-                    true
-                    );
-            int srcLaneCount = laneList.Count;
-
-            bool bLeft, bRight, bForward;
-            ref ExtSegmentEnd segEnd = ref GetSegEnd(segmentId, nodeId);
-            segEndMan.CalculateOutgoingLeftStraightRightSegments(ref segEnd, ref node, out bLeft, out bForward, out bRight);
-
-            bool lhd = LaneArrowManager.Instance.Services.SimulationService.LeftHandDrive;
-            LaneArrows arrowShort = lhd ? LaneArrows.Left : LaneArrows.Right;
-            LaneArrows arrowLong = lhd ? LaneArrows.Right : LaneArrows.Left;
-            for (int i = 0; i < srcLaneCount; ++i) {
-                uint laneId = laneList[i].laneId;
-                LaneArrows arrows = LaneArrowManager.Instance.GetFinalLaneArrows(laneId);
-                LaneArrowManager.Instance.RemoveLaneArrows(
-                    laneId,
-                    arrowLong);
-
-                if (arrows != arrowShort) {
-                    LaneArrowManager.Instance.SetLaneArrows(
-                        laneList[i].laneId,
-                        LaneArrows.Forward);
-                }
-            }
-
-            bool bShort = lhd ? bLeft : bRight;
-            if (srcLaneCount > 0 && bShort) {
-                //TODO LHD righMostLane
-                LanePos righMostLane = laneList[laneList.Count - 1];
-                LaneArrowManager.Instance.AddLaneArrows(righMostLane.laneId, arrowShort);
-            }
-
-        }
-
-        private static void FixMinorSegmentLanes(ushort segmentId, ushort nodeId, ref List<ushort> segList) {
-            if (LaneArrowManager.SeparateTurningLanes.CanChangeLanes(segmentId, nodeId) != SetLaneArrowError.Success) {
-                Debug.Log("can't change lanes");
-                return;
-            }
-            ref NetSegment seg = ref GetSeg(segmentId);
-            ref NetNode node = ref GetNode(nodeId);
-            bool startNode = (bool)netService.IsStartNode(segmentId, nodeId);
-
-            //list of outgoing lanes from current segment to current node.
-            IList<LanePos> laneList =
-                netService.GetSortedLanes(
-                    segmentId,
-                    ref seg,
-                    startNode,
-                    LaneArrowManager.LANE_TYPES,
-                    LaneArrowManager.VEHICLE_TYPES,
-                    true
-                    );
-            int srcLaneCount = laneList.Count;
-
-            bool bLeft, bRight, bForward;
-            ref ExtSegmentEnd segEnd = ref GetSegEnd(segmentId, nodeId);
-            segEndMan.CalculateOutgoingLeftStraightRightSegments(ref segEnd, ref node, out bLeft, out bForward, out bRight);
-
-            // LHD vs RHD variables.
-            bool lhd = LaneArrowManager.Instance.Services.SimulationService.LeftHandDrive;
-            ArrowDirection nearDir = lhd ? ArrowDirection.Left : ArrowDirection.Right;
-            LaneArrows nearArrow   = lhd ? LaneArrows.Left     : LaneArrows.Right;
-            bool             bnear = lhd ? bLeft               : bRight;
-            int sideLaneIndex      = lhd ? srcLaneCount - 1    : 0;
-
-            LaneArrows turnArrow = nearArrow;
-            {
-                // Check for slight turn into the main road.
-                ArrowDirection dir0 = segEndMan.GetDirection(ref segEnd, segList[0]);
-                ArrowDirection dir1 = segEndMan.GetDirection(ref segEnd, segList[1]);
-                Debug.Assert(dir1 != dir0); // Assume main road is not angled: then dir1 != dir0
-                if (dir0 != nearDir && dir1 != nearDir) {
-                    turnArrow = LaneArrows.Forward; //slight turn uses forward arrow.
-                }
-            }
-
-            // only take the near turn into main road.
-            for (int i = 0; i < srcLaneCount; ++i) {
-                LaneArrowManager.Instance.SetLaneArrows(laneList[i].laneId, turnArrow);
-            }
-
-            /* in case there are multiple minor roads attached to the priority road at the same side
-             * and the main road is straigh, then add a turn arrow into the other minor roads.
-             */
-            if(srcLaneCount > 0 && bnear && turnArrow == LaneArrows.Forward) {
-                LaneArrowManager.Instance.AddLaneArrows( //TODO test
-                    laneList[sideLaneIndex].laneId,
-                    nearArrow);
-            }
-        }
-
-        private static int CompareSegments(ushort seg1Id, ushort seg2Id) {
-            ref NetSegment seg1 = ref GetSeg(seg1Id);
-            ref NetSegment seg2 = ref GetSeg(seg2Id);
-            int diff = (int)Math.Ceiling(seg2.Info.m_halfWidth - seg1.Info.m_halfWidth);
-            if (diff == 0) {
-                diff = CountCarLanes(seg2Id) - CountCarLanes(seg1Id);
-            }
-            return diff;
-        }
-
-        private static int CountCarLanes(ushort segmentId) {
-            ref NetSegment segment = ref GetSeg(segmentId);
-            int forward = 0, backward = 0;
-            segment.CountLanes(
-                segmentId,
-                        NetInfo.LaneType.Vehicle | NetInfo.LaneType.TransportVehicle,
-                        VehicleInfo.VehicleType.Car,
-                        ref forward,
-                        ref backward);
-            return forward + backward;
-        }
-    } //end class
-}
diff --git a/TLM/TLM/Util/RoundaboutMassEdit.cs b/TLM/TLM/Util/RoundaboutMassEdit.cs
deleted file mode 100644
index 442ba91..0000000
--- a/TLM/TLM/Util/RoundaboutMassEdit.cs
+++ /dev/null
@@ -1,312 +0,0 @@
-namespace TrafficManager.Util {
-    using System;
-    using System.Collections.Generic;
-    using UnityEngine;
-    using API.Traffic.Data;
-    using CSUtil.Commons;
-    using TrafficManager.Manager.Impl;
-    using API.Traffic.Enums;
-    using GenericGameBridge.Service;
-    using State;
-    using static Util.Shortcuts;
-    using static Manager.Impl.LaneArrowManager.SeparateTurningLanes;
-    using static UI.SubTools.LaneConnectorTool;
-
-    public class RoundaboutMassEdit {
-        public static RoundaboutMassEdit Instance = new RoundaboutMassEdit();
-        public RoundaboutMassEdit() {
-            segmentList = new List<ushort>();
-        }
-
-        private List<ushort> segmentList = null;
-
-        public static void FixLanesRAbout(ushort segmentId, ushort nextSegmentId) {
-            ushort nodeId = netService.GetHeadNode(segmentId);
-
-            if (OptionsMassEditTab.rabout_StayInLaneMainR && !HasJunctionFlag(nodeId)) {
-                StayInLane(nodeId, StayInLaneMode.Both);
-            }
-
-            // allocation of dedicated exit lanes is supported only when the roundabout is round
-            // in which case the next segment should be straigh ahead.
-            bool isStraight = segEndMan.GetDirection(segmentId, nextSegmentId, nodeId) == ArrowDirection.Forward;
-
-            if (OptionsMassEditTab.rabout_DedicatedExitLanes &&
-                HasJunctionFlag(nodeId) &&
-                CanChangeLanes(segmentId, nodeId) == SetLaneArrowError.Success &&
-                isStraight) {
-                bool startNode = (bool)netService.IsStartNode(segmentId, nodeId);
-                IList<LanePos> laneList =
-                    netService.GetSortedLanes(
-                        segmentId,
-                        ref GetSeg(segmentId),
-                        startNode,
-                        LaneArrowManager.LANE_TYPES,
-                        LaneArrowManager.VEHICLE_TYPES,
-                        true);
-                int nSrc = laneList.Count;
-
-                // check for exits.
-                segEndMan.CalculateOutgoingLeftStraightRightSegments(
-                    ref GetSegEnd(segmentId, nodeId),
-                    ref GetNode(nodeId),
-                    out bool bLeft,
-                    out bool bForward,
-                    out bool bRight);
-
-                //Set one dedicated exit lane per exit - if there are enough lanes that is.
-                switch (nSrc) {
-                    case 0:
-                        Debug.LogAssertion("The road is the wrong way around.");
-                        break;
-                    case 1:
-                        break;// not enough lanes Use default settings.
-                    case 2:
-                        if (bRight && bLeft) {
-                            // not enough lanes, use default settings
-                        } else if (bRight) {
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[0].laneId, LaneArrows.Forward);
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[1].laneId, LaneArrows.Right);
-                        } else if (bLeft) {
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[0].laneId, LaneArrows.Left);
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[1].laneId, LaneArrows.Forward);
-                        } else {
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[0].laneId, LaneArrows.Forward);
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[1].laneId, LaneArrows.Forward);
-                        }
-                        break;
-                    default:
-                        for (int i = 0; i < laneList.Count; ++i) {
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[i].laneId, LaneArrows.Forward);
-                        }
-                        if (bRight) {
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[nSrc - 1].laneId, LaneArrows.Right);
-                        }
-                        if (bLeft) {
-                            LaneArrowManager.Instance.SetLaneArrows(laneList[0].laneId, LaneArrows.Left);
-                        }
-                        break;
-                } // end switch
-            } // end if
-        }
-
-        private static void FixRulesRAbout(ushort segmentId) {
-            foreach (bool startNode in Constants.ALL_BOOL) {
-                if (OptionsMassEditTab.rabout_PrioritySigns) {
-                    TrafficPriorityManager.Instance.SetPrioritySign(
-                        segmentId,
-                        startNode,
-                        PriorityType.Main);
-                }
-
-                ushort nodeId = netService.GetSegmentNodeId(
-                    segmentId,
-                    startNode);
-
-                ExtSegmentEnd curEnd = GetSegEnd(segmentId, startNode);
-
-                if (OptionsMassEditTab.rabout_NoCrossMainR) {
-                    JunctionRestrictionsManager.Instance.SetPedestrianCrossingAllowed(
-                        segmentId,
-                        startNode,
-                        false);
-                }
-                JunctionRestrictionsManager.Instance.SetEnteringBlockedJunctionAllowed(
-                    segmentId,
-                    startNode,
-                    true);
-            }
-        }
-
-        private static void FixRulesMinor(ushort segmentId, ushort nodeId) {
-            bool startNode = (bool)netService.IsStartNode(segmentId, nodeId);
-            bool isHighway = ExtNodeManager.IsHighwayJunction(nodeId);
-
-            if (OptionsMassEditTab.rabout_NoCrossYeildR) {
-                JunctionRestrictionsManager.Instance.SetPedestrianCrossingAllowed(
-                    segmentId,
-                    startNode,
-                    false);
-            }
-            if (OptionsMassEditTab.rabout_PrioritySigns) {
-                TrafficPriorityManager.Instance.SetPrioritySign(
-                    segmentId,
-                    startNode,
-                    PriorityType.Yield);
-            }
-
-            if (isHighway) {
-                //ignore highway rules: //TODO remove as part of issue #569
-                JunctionRestrictionsManager.Instance.SetLaneChangingAllowedWhenGoingStraight(segmentId, startNode, true);
-            } // endif
-        }
-
-        private static void FixLanesMinor(ushort segmentId, ushort nodeId) {
-            int shortUnit = 4;
-            int meterPerUnit = 8;
-            ref NetSegment seg = ref GetSeg(segmentId);
-            ushort otherNodeId = seg.GetOtherNode(nodeId);
-
-            if (OptionsMassEditTab.rabout_StayInLaneNearRabout &&
-                !HasJunctionFlag(otherNodeId) &&
-                seg.m_averageLength < shortUnit * meterPerUnit) {
-                StayInLane(otherNodeId, StayInLaneMode.Both);
-            }
-        }
-
-        private void FixMinor(ushort nodeId) {
-            ref NetNode node = ref GetNode(nodeId);
-            for (int i = 0; i < 8; ++i) {
-                //find connected segments.
-                ushort segmentId = node.GetSegment(i);
-                if (segmentId == 0 || segmentList.Contains(segmentId)) {
-                    continue; // continue if it is part of roundabout
-                } // end if
-
-                FixRulesMinor(segmentId, nodeId);
-                FixLanesMinor(segmentId, nodeId);
-            }//end for
-        }
-
-        /// <summary>
-        /// Fixes the round about or returns false if it is not a round about.
-        /// </summary>
-        /// <param name="segmentId"></param>
-        /// <returns></returns>
-        public bool FixRabout(ushort initialSegmentId) {
-            bool isRAbout = TraverseLoop(initialSegmentId, out _);
-            if (!isRAbout) {
-                Log._Debug($"segment {initialSegmentId} not a roundabout.");
-                return false;
-            }
-            int count = segmentList.Count;
-            Log._Debug($"\n segmentId={initialSegmentId} seglist.count={count}\n");
-
-            for (int i = 0; i < count; ++i) {
-                ushort segId = segmentList[i];
-                ushort nextSegId = segmentList[(i + 1) % count];
-                FixLanesRAbout(segId, nextSegId);
-                FixRulesRAbout(segId);
-                FixMinor(netService.GetHeadNode(segId));
-            }
-            return true;
-        }
-
-        /// <summary>
-        /// Traverses around a roundabout. At each
-        /// traversed segment, the given `visitor` is notified.
-        /// </summary>
-        /// <param name="initialSegmentGeometry">Specifies the segment at which the traversal
-        ///     should start.</param>
-        /// <param name="visitorFun">Specifies the stateful visitor that should be notified as soon as
-        ///     a traversable segment (which has not been traversed before) is found.
-        /// pass null if you are trying to see if segment is part of a round about.
-        /// </param>
-        /// <returns>true if its a roundabout</returns>
-        public bool TraverseLoop(ushort segmentId, out List<ushort> segList) {
-            this.segmentList.Clear();
-            bool ret;
-            if (segmentId == 0 || ! segMan.CalculateIsOneWay(segmentId)) {
-                ret = false;
-            } else {
-                ret = TraverseAroundRecursive(segmentId);
-            }
-            segList = this.segmentList;
-            return ret;
-        }
-
-        private bool TraverseAroundRecursive(ushort segmentId) {
-            if (segmentList.Count > 20) {
-                return false; // too long. prune
-            }
-            segmentList.Add(segmentId);
-            var segments = GetSortedSegments( segmentId);
-
-            foreach (var nextSegmentId in segments) {
-                bool isRAbout = false;
-                if (nextSegmentId == segmentList[0]) {
-                    isRAbout = true;
-                } else if (Contains(nextSegmentId)) {
-                    isRAbout = false;
-                } else {
-                    isRAbout = TraverseAroundRecursive(nextSegmentId);
-                }
-                if (isRAbout) {
-                    return true;
-                } //end if
-            }// end foreach
-            segmentList.Remove(segmentId);
-            return false;
-        }
-
-        private static List<ushort> GetSortedSegments(ushort segmentId) {
-            ushort headNodeId = netService.GetHeadNode(segmentId);
-            bool lht = LaneArrowManager.Instance.Services.SimulationService.LeftHandTraffic;
-            var list0 = GetSortedSegmentsHelper( headNodeId, segmentId, ArrowDirection.Forward, !lht);
-            var list1 = GetSortedSegmentsHelper( headNodeId, segmentId, ArrowDirection.Left   ,  lht);
-            var list2 = GetSortedSegmentsHelper( headNodeId, segmentId, ArrowDirection.Right  , !lht);
-
-            list0.AddRange(list1);
-            list0.AddRange(list2);
-            return list0;
-        }
-
-        private static List<ushort> GetSortedSegmentsHelper(
-            ushort headNodeId,
-            ushort segmentId,
-            ArrowDirection dir,
-            bool preferLeft) {
-            ArrowDirection preferDir = preferLeft ? ArrowDirection.Left : ArrowDirection.Right;
-            List<ushort> sortedSegList = new List<ushort>();
-
-            netService.IterateNodeSegments(
-                headNodeId,
-                ClockDirection.CounterClockwise,
-                (ushort NextSegmentId, ref NetSegment _) => {
-                    if (!IsPartofRoundabout(NextSegmentId, segmentId, headNodeId)) {
-                        return true;
-                    }
-                    if (segEndMan.GetDirection(segmentId, NextSegmentId, headNodeId) == dir) {
-                        for (int i = 0; i < sortedSegList.Count; ++i) {
-                            if (segEndMan.GetDirection(NextSegmentId, sortedSegList[i], headNodeId) == preferDir) {
-                                sortedSegList.Insert(i, NextSegmentId);
-                                return true;
-                            }
-                        }
-                        sortedSegList.Add(NextSegmentId);
-                    }
-                    return true;
-                });
-            return sortedSegList;
-        }
-
-        /// <summary>
-        /// Checks wheather the next segmentId looks like to be part of a roundabout.
-        /// Assumes prevSegmentId is oneway
-        /// </summary>
-        /// <param name="nextSegmentId"></param>
-        /// <param name="prevSegmentId"></param>
-        /// <param name="headNodeId">head node for prevSegmentId</param>
-        /// <returns></returns>
-        private static bool IsPartofRoundabout( ushort nextSegmentId, ushort prevSegmentId, ushort headNodeId) {
-            bool ret = nextSegmentId != 0 && nextSegmentId != prevSegmentId;
-            ret &= segMan.CalculateIsOneWay(nextSegmentId);
-            ret &= headNodeId == netService.GetTailNode(nextSegmentId);
-            return ret;
-        }
-
-        /// <summary>
-        /// returns true if the given segment is attached to the middle of the
-        /// path of segmentList by checking for duplicate nodes.
-        /// </summary>
-        private bool Contains(ushort segmentId) {
-            ushort nodeId = netService.GetHeadNode(segmentId);
-            foreach (ushort segId in segmentList) {
-                if (netService.GetHeadNode(segId) == nodeId) {
-                    return true;
-                }
-            }
-            return false;
-        }
-    } // end class
-}//end namespace
\ No newline at end of file
diff --git a/TLM/TLM/Util/SegmentTraverser.cs b/TLM/TLM/Util/SegmentTraverser.cs
index 2f4ff3b..2293d33 100644
--- a/TLM/TLM/Util/SegmentTraverser.cs
+++ b/TLM/TLM/Util/SegmentTraverser.cs
@@ -1,9 +1,8 @@
-namespace TrafficManager.Util {
+﻿namespace TrafficManager.Util {
     using System;
     using System.Collections.Generic;
     using API.Manager;
     using API.Traffic.Data;
-    using ColossalFramework;
     using CSUtil.Commons;
 
     public class SegmentTraverser {
@@ -78,38 +77,6 @@ namespace TrafficManager.Util {
             }
         }
 
-        public static void Traverse(List<ushort> segmentList, SegmentVisitor visitorFun) {
-            if (segmentList == null) {
-                return;
-            }
-            ushort prevSegId = 0;
-            ExtSegment[] extSegment_buffer = Constants.ManagerFactory.ExtSegmentManager.ExtSegments;
-            NetSegment[] segment_buffer = Singleton<NetManager>.instance.m_segments.m_buffer;
-            foreach (var segId in segmentList) {
-                SegmentTraverser.SegmentVisitData data;
-                if (prevSegId == 0) {
-                    data = new SegmentVisitData(
-                        ref extSegment_buffer[segId],
-                        ref extSegment_buffer[segId],
-                        false,
-                        false,
-                        true);
-                } else {
-                    data = new SegmentVisitData(
-                        ref extSegment_buffer[prevSegId],
-                        ref extSegment_buffer[segId],
-                        true,
-                        segment_buffer[prevSegId].m_endNode == segment_buffer[segId].m_startNode,
-                        false);
-                }
-                if (!visitorFun(data)) {
-                    break;
-                }
-                prevSegId = segId;
-            }
-
-        }
-
         /// <summary>
         /// Performs a Depth-First traversal over the cached segment geometry structure. At each
         /// traversed segment, the given `visitor` is notified. It then can update the current `state`.
diff --git a/TLM/TLM/Util/Shortcuts.cs b/TLM/TLM/Util/Shortcuts.cs
deleted file mode 100644
index 0ce6cc9..0000000
--- a/TLM/TLM/Util/Shortcuts.cs
+++ /dev/null
@@ -1,40 +0,0 @@
-namespace TrafficManager.Util {
-    using System;
-    using ColossalFramework;
-    using CSUtil.Commons;
-    using GenericGameBridge.Service;
-    using TrafficManager.API.Manager;
-    using TrafficManager.API.Traffic.Data;
-    using static Constants;
-
-    internal static class Shortcuts {
-        private static NetNode[] _nodeBuffer => Singleton<NetManager>.instance.m_nodes.m_buffer;
-
-        private static NetSegment[] _segBuffer => Singleton<NetManager>.instance.m_segments.m_buffer;
-
-        private static ExtSegmentEnd[] _segEndBuff => segEndMan.ExtSegmentEnds;
-
-        internal static IExtSegmentEndManager segEndMan => ManagerFactory.ExtSegmentEndManager;
-
-        internal static IExtSegmentManager segMan => ManagerFactory.ExtSegmentManager;
-
-        internal static INetService netService => ServiceFactory.NetService;
-
-        internal static ref NetNode GetNode(ushort nodeId) => ref _nodeBuffer[nodeId];
-
-        internal static ref NetSegment GetSeg(ushort segmentId) => ref _segBuffer[segmentId];
-
-        internal static ref ExtSegmentEnd GetSegEnd(ushort segmentId, ushort nodeId) =>
-            ref _segEndBuff[segEndMan.GetIndex(segmentId, nodeId)];
-
-        internal static ref ExtSegmentEnd GetSegEnd(ushort segmentId, bool startNode) =>
-            ref _segEndBuff[segEndMan.GetIndex(segmentId, startNode)];
-
-        internal static bool HasJunctionFlag(ushort nodeId) => HasJunctionFlag(ref GetNode(nodeId));
-
-        internal static bool HasJunctionFlag(ref NetNode node) =>
-            (node.m_flags & NetNode.Flags.Junction) != NetNode.Flags.None;
-
-        internal static Func<bool, int> Int = (bool b) => b ? 1 : 0;
-    }
-}
diff --git a/TLM/TLM/packages.config b/TLM/TLM/packages.config
index 6d0be5d..850f38e 100644
--- a/TLM/TLM/packages.config
+++ b/TLM/TLM/packages.config
@@ -1,10 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <packages>
-  <package id="Microsoft.CodeAnalysis.FxCopAnalyzers" version="2.9.7" targetFramework="net35" developmentDependency="true" />
-  <package id="Microsoft.CodeAnalysis.VersionCheckAnalyzer" version="2.9.7" targetFramework="net35" developmentDependency="true" />
-  <package id="Microsoft.CodeQuality.Analyzers" version="2.9.7" targetFramework="net35" developmentDependency="true" />
-  <package id="Microsoft.NetCore.Analyzers" version="2.9.7" targetFramework="net35" developmentDependency="true" />
-  <package id="Microsoft.NetFramework.Analyzers" version="2.9.7" targetFramework="net35" developmentDependency="true" />
   <package id="ReflectionIT.Analyzer.Structs" version="0.1.0" targetFramework="net35" />
   <package id="StyleCop.Analyzers" version="1.0.2" targetFramework="net35" developmentDependency="true" />
 </packages>
\ No newline at end of file
diff --git a/TLM/TMPE.API/Manager/IExtSegmentEndManager.cs b/TLM/TMPE.API/Manager/IExtSegmentEndManager.cs
index 43f872b..56f1e11 100644
--- a/TLM/TMPE.API/Manager/IExtSegmentEndManager.cs
+++ b/TLM/TMPE.API/Manager/IExtSegmentEndManager.cs
@@ -1,4 +1,4 @@
-namespace TrafficManager.API.Manager {
+﻿namespace TrafficManager.API.Manager {
     using CSUtil.Commons;
     using Traffic.Data;
 
@@ -58,16 +58,6 @@ namespace TrafficManager.API.Manager {
         /// <returns>compass direction</returns>
         ArrowDirection GetDirection(ref ExtSegmentEnd sourceEnd, ushort targetSegmentId);
 
-        /// <summary>
-        /// Determines the relative compass direction from the given source end to the target segment.
-        /// </summary>
-        /// <param name="segmentId0">source segment end</param>
-        /// <param name="segmentId1">target segment id</param>
-        /// <param name="nodeId">Shared node. If not provided, shared node is determined automatically.</param>
-        /// <returns>compass direction</returns>
-        ArrowDirection GetDirection(ushort segmentId0, ushort segmentId1, ushort nodeId = 0);
-
-
         /// <summary>
         /// Determines whether the segment end is connected to highways only.
         /// </summary>
diff --git a/TLM/TMPE.CitiesGameBridge/Service/NetService.cs b/TLM/TMPE.CitiesGameBridge/Service/NetService.cs
index e7ec450..2791f1d 100644
--- a/TLM/TMPE.CitiesGameBridge/Service/NetService.cs
+++ b/TLM/TMPE.CitiesGameBridge/Service/NetService.cs
@@ -404,30 +404,5 @@ namespace CitiesGameBridge.Service {
                 });
             return ret;
         }
-
-        public ushort GetHeadNode(ref NetSegment segment) {
-            // tail node>-------->head node
-            bool invert = (segment.m_flags & NetSegment.Flags.Invert) != NetSegment.Flags.None;
-            if (invert) {
-                return segment.m_startNode;
-            } else {
-                return segment.m_endNode;
-            }
-        }
-
-        public ushort GetHeadNode(ushort segmentId) =>
-            GetHeadNode(ref Singleton<NetManager>.instance.m_segments.m_buffer[segmentId]);
-
-        public ushort GetTailNode(ref NetSegment segment) {
-            bool invert = (segment.m_flags & NetSegment.Flags.Invert) != NetSegment.Flags.None;
-            if (!invert) {
-                return segment.m_startNode;
-            } else {
-                return segment.m_endNode;
-            }//endif
-        }
-
-        public ushort GetTailNode(ushort segmentId) =>
-            GetTailNode(ref Singleton<NetManager>.instance.m_segments.m_buffer[segmentId]);
     }
 }
\ No newline at end of file
diff --git a/TLM/TMPE.CitiesGameBridge/Service/SimulationService.cs b/TLM/TMPE.CitiesGameBridge/Service/SimulationService.cs
index f1edd0f..da81dcf 100644
--- a/TLM/TMPE.CitiesGameBridge/Service/SimulationService.cs
+++ b/TLM/TMPE.CitiesGameBridge/Service/SimulationService.cs
@@ -1,4 +1,4 @@
-namespace CitiesGameBridge.Service {
+﻿namespace CitiesGameBridge.Service {
     using System;
     using ColossalFramework;
     using ColossalFramework.Math;
@@ -10,9 +10,7 @@ namespace CitiesGameBridge.Service {
 
         private SimulationService() { }
 
-        public bool LeftHandDrive => LeftHandTraffic; // Intentionally wrong for legacy reasons. issue #577
-
-        public bool LeftHandTraffic =>
+        public bool LeftHandDrive =>
             Singleton<SimulationManager>.instance.m_metaData.m_invertTraffic
             == SimulationMetaData.MetaBool.True;
 
diff --git a/TLM/TMPE.GenericGameBridge/Service/INetService.cs b/TLM/TMPE.GenericGameBridge/Service/INetService.cs
index 5e30bef..390bb08 100644
--- a/TLM/TMPE.GenericGameBridge/Service/INetService.cs
+++ b/TLM/TMPE.GenericGameBridge/Service/INetService.cs
@@ -1,4 +1,4 @@
-namespace GenericGameBridge.Service {
+﻿namespace GenericGameBridge.Service {
     using System.Collections.Generic;
 
     public delegate bool NetSegmentHandler(ushort segmentId, ref NetSegment segment);
@@ -112,17 +112,5 @@ namespace GenericGameBridge.Service {
         void PublishSegmentChanges(ushort segmentId);
 
         bool? IsStartNode(ushort segmentId, ushort nodeId);
-
-        /// <summary>tail node>-------->head node</summary>
-        ushort GetHeadNode(ushort segmentId);
-
-        /// <summary>tail node>-------->head node</summary>
-        ushort GetHeadNode(ref NetSegment segment);
-
-        /// <summary>tail node>-------->head node</summary>
-        ushort GetTailNode(ushort segmentId);
-
-        /// <summary>tail node>-------->head node</summary>
-        ushort GetTailNode(ref NetSegment segment);
     }
 }
\ No newline at end of file
diff --git a/TLM/TMPE.GenericGameBridge/Service/ISimulationService.cs b/TLM/TMPE.GenericGameBridge/Service/ISimulationService.cs
index e3d5102..6e44b6f 100644
--- a/TLM/TMPE.GenericGameBridge/Service/ISimulationService.cs
+++ b/TLM/TMPE.GenericGameBridge/Service/ISimulationService.cs
@@ -1,16 +1,9 @@
-namespace GenericGameBridge.Service {
+﻿namespace GenericGameBridge.Service {
     using ColossalFramework.Math;
-    using System;
     using UnityEngine;
 
     public interface ISimulationService {
-        /// <summary>
-        /// The implementation of this property confuses Left hand drive and left hand traffic.
-        /// </summary>
-        [Obsolete]
-        bool LeftHandDrive { get; } // Issue #577
-
-        bool LeftHandTraffic { get; }
+        bool LeftHandDrive { get; }
 
         uint CurrentBuildIndex { get; set; }
 
